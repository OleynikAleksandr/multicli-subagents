#!/bin/sh
# Exit on any error
set -e

# Run Architecture Check FIRST
echo "ðŸ—ï¸  Running Architecture Check..."
./scripts/check-architecture.sh

# Check if there are any staged files
if [ -z "$(git diff --cached --name-only)" ]; then
  echo "No staged files to format"
  exit 0
fi

# Store the hash of staged changes to detect modifications
# Use shasum if sha256sum isn't available (macOS)
if command -v sha256sum >/dev/null 2>&1; then
  SUM_CMD="sha256sum"
else
  SUM_CMD="shasum -a 256"
fi

STAGED_HASH=$(git diff --cached | $SUM_CMD | cut -d' ' -f1)

# Save list of staged files (handling all file states)
STAGED_FILES=$(git diff --cached --name-only --diff-filter=ACMR)
PARTIALLY_STAGED=$(git diff --name-only)

# Stash unstaged changes to preserve working directory
# --keep-index keeps staged changes in working tree
# Check if there are unstaged changes first
if ! git diff --quiet; then
  git stash push --quiet --keep-index --message "pre-commit-stash"
  STASHED=0
else
  STASHED=1
fi

# Run formatter on the staged files
echo "âœ¨ Running Ultracite Fix..."
npx ultracite fix
FORMAT_EXIT_CODE=$?

# Restore working directory state
if [ $STASHED -eq 0 ]; then
  # Re-stage the formatted files
  if [ -n "$STAGED_FILES" ]; then
    echo "$STAGED_FILES" | while IFS= read -r file; do
      if [ -f "$file" ]; then
        git add "$file"
      fi
    done
  fi
  
  # Restore unstaged changes
  git stash pop --quiet || true
else
  # No stash was created, just re-add the formatted files
  if [ -n "$STAGED_FILES" ]; then
    echo "$STAGED_FILES" | while IFS= read -r file; do
      if [ -f "$file" ]; then
        git add "$file"
      fi
    done
  fi
fi

# Check if staged files actually changed
NEW_STAGED_HASH=$(git diff --cached | $SUM_CMD | cut -d' ' -f1)
if [ "$STAGED_HASH" != "$NEW_STAGED_HASH" ]; then
  echo "âœ¨ Files formatted by Ultracite"
fi

exit $FORMAT_EXIT_CODE
